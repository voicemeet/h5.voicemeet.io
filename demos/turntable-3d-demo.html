<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>3D转盘</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      button {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 1;
        padding: 10px 20px;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <button onclick="rotateToIndex(3)">转到第4张图</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>

    <script>
      const scene = new THREE.Scene()
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)
      camera.position.set(0, 0, 20)

      const renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth, window.innerHeight)
      document.body.appendChild(renderer.domElement)

      const light = new THREE.PointLight(0xffffff, 1)
      light.position.set(0, 10, 25)
      scene.add(light)

      const group = new THREE.Group()
      // const tiltDeg = 10;
      // group.rotation.x = THREE.MathUtils.degToRad(tiltDeg);
      scene.add(group)

      const imageUrls = [
        'https://picsum.photos/id/1011/200/300',
        'https://picsum.photos/id/1012/200/300',
        'https://picsum.photos/id/1015/200/300',
        'https://picsum.photos/id/1020/200/300',
        'https://picsum.photos/id/1025/200/300',
        'https://picsum.photos/id/1031/200/300',
        'https://picsum.photos/id/1035/200/300',
        'https://picsum.photos/id/1040/200/300',
      ]

      const loader = new THREE.TextureLoader()
      const radius = 10
      const itemCount = imageUrls.length

      imageUrls.forEach((url, i) => {
        loader.load(url, (texture) => {
          const imageWidth = 3,
            imageHeight = 4.5
          const groupItem = new THREE.Group()

          // 图片平面
          const imageGeometry = new THREE.PlaneGeometry(imageWidth, imageHeight)
          const imageMaterial = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
          const imageMesh = new THREE.Mesh(imageGeometry, imageMaterial)
          groupItem.add(imageMesh)

          // 背景板（用于放文字）放在上面一部分
          const bgHeight = imageHeight * 0.2
          const bgGeometry = new THREE.PlaneGeometry(imageWidth, bgHeight)
          const bgMaterial = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.5,
            polygonOffset: true,
            polygonOffsetFactor: 1,
            polygonOffsetUnits: 1,
            depthWrite: false, // 禁用深度写入，避免与其他物体发生深度冲突
            depthTest: true, // 保持深度测试
          })
          const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial)
          bgMesh.position.y = imageHeight / 2 - bgHeight / 2 - 0.1
          bgMesh.position.z = 0.01
          bgMesh.lookAt(camera.position)
          groupItem.add(bgMesh)

          // 文本（使用 canvas 生成纹理）
          const canvas = document.createElement('canvas')
          canvas.width = 256
          canvas.height = 64
          const ctx = canvas.getContext('2d')
          ctx.fillStyle = 'white'
          ctx.font = '28px sans-serif'
          ctx.textAlign = 'center'
          ctx.fillText('图片 ' + (i + 1), canvas.width / 2, 42) // 文字内容

          const textTexture = new THREE.CanvasTexture(canvas)
          const textMaterial = new THREE.MeshBasicMaterial({
            map: textTexture,
            transparent: true,
            // polygonOffset: true,
            // polygonOffsetFactor: 1,
            // polygonOffsetUnits: 1,
            depthWrite: false, // 禁用深度写入，避免与其他物体发生深度冲突
            depthTest: true, // 保持深度测试
          })
          const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(imageWidth, bgHeight), textMaterial)
          textMesh.position.y = bgMesh.position.y
          textMesh.position.z = 0.015
          textMesh.lookAt(camera.position)
          groupItem.add(textMesh)

          // 放置整个组的位置
          const angle = (i / itemCount) * Math.PI * 2
          const x = Math.cos(angle) * radius
          const z = Math.sin(angle) * radius
          groupItem.position.set(x, 0, z)
          groupItem.lookAt(0, 0, 0)

          group.add(groupItem)
        })
      })

      // 初始旋转动画
      let spinning = gsap.to(group.rotation, {
        y: '+=' + Math.PI * 2,
        duration: 20,
        repeat: -1,
        ease: 'linear',
      })

      // 旋转并对准某一索引
      function rotateToIndex(index, turns = 2) {
        spinning.kill() // 停止当前旋转

        const fullCircle = Math.PI * 2
        const targetUnitAngle = (index / itemCount) * fullCircle

        // 当前角度修正为正值
        let currentY = group.rotation.y % fullCircle
        if (currentY < 0) currentY += fullCircle

        // 要达到的最终角度（在当前角度基础上旋转N圈，并精准对准目标角）
        const finalY = currentY + turns * fullCircle - (currentY - targetUnitAngle)

        // 动画执行
        gsap.to(group.rotation, {
          y: finalY,
          duration: 3 + turns, // 时间随着圈数略增加
          ease: 'power4.out',
        })
      }

      function autoTiltGroup(group, camera, options = {}) {
        const {
          maxTiltDeg = 25, // 最倾斜（如移动端）
          minTiltDeg = 5, // 最正面（如大屏）
          baseHeight = 800, // 屏幕参考高度
        } = options

        const screenHeight = window.innerHeight
        const ratio = THREE.MathUtils.clamp(screenHeight / baseHeight, 0.5, 1.5)

        // 插值计算当前倾角：屏幕越矮，倾斜越多
        const tiltDeg = THREE.MathUtils.lerp(minTiltDeg, maxTiltDeg, 1 - (ratio - 0.5))
        const tiltRad = THREE.MathUtils.degToRad(tiltDeg) // 正值 = 向下倾斜

        group.rotation.x = tiltRad
      }

      autoTiltGroup(group, camera)

      // 渲染循环
      function animate() {
        requestAnimationFrame(animate)
        renderer.render(scene, camera)
      }
      animate()

      // 响应式
      window.addEventListener('resize', () => {
        autoTiltGroup(group, camera)
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      })
    </script>
  </body>
</html>
